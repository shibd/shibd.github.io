<!DOCTYPE html>
<html lang='zh-CN'>

<head>
  <meta name="generator" content="Hexo 5.4.0">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://cdn.jsdelivr.net'>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  <title>使用Spring Websocket Stomp协议设计推送中心 - 无敌小包子</title>

  
    <meta name="description" content="概述本文是WebSocket推送中心的第二章节， 本系列文章是在Spring Websocket Stomp的基础上实现的推送系统，计划包含如下几篇文章： 第一篇：Spring Websocket Stomp介绍第二篇：基于Websocket Stomp的推送中心实现第三篇：推送中心单机支持百万级连接的晋级之路第四篇：推送中心的集群架构方案设计落地 本章主线上篇文章介绍了Spring WebSoc">
<meta property="og:type" content="article">
<meta property="og:title" content="Websocket推送中心(二)-基于Stomp的推送中心设计">
<meta property="og:url" content="https://shibd.github.io/message-center-2/">
<meta property="og:site_name" content="无敌小包子">
<meta property="og:description" content="概述本文是WebSocket推送中心的第二章节， 本系列文章是在Spring Websocket Stomp的基础上实现的推送系统，计划包含如下几篇文章： 第一篇：Spring Websocket Stomp介绍第二篇：基于Websocket Stomp的推送中心实现第三篇：推送中心单机支持百万级连接的晋级之路第四篇：推送中心的集群架构方案设计落地 本章主线上篇文章介绍了Spring WebSoc">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://shibd.github.io/image/message-center/architecture2.jpg">
<meta property="og:image" content="https://shibd.github.io/image/message-center/auth.jpg">
<meta property="article:published_time" content="2019-08-16T00:00:00.000Z">
<meta property="article:modified_time" content="2019-08-16T00:00:00.000Z">
<meta property="article:author" content="baozi">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="架构">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://shibd.github.io/image/message-center/architecture2.jpg">
  
  

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  
    <link rel="shortcut icon" href="/image/base/apple-touch-icon.png">
  

  
</head>

<body>
  


  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    


<header class="header">

<div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://cdn.jsdelivr.net/gh/cdn-x/placeholder@1.0.2/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="/image/base/apple-touch-icon.png" onerror="javascript:this.classList.add('error');this.src='https://cdn.jsdelivr.net/gh/cdn-x/placeholder@1.0.1/image/2659360.svg';"></a><a class="title" href="/"><div class="main">无敌小包子</div><div class="sub normal cap">搏一世</div><div class="sub hover cap" style="opacity:0">shibd.github.io</div></a></div>
<nav class="menu dis-select"><a class="nav-item active" href="/">文章</a><a class="nav-item" href="/wiki/">项目</a><a class="nav-item" href="/about/">关于</a></nav></header>

<div class="widgets">

<div class="widget-wrap single" id="toc"><div class="widget-header cap dis-select"><span class="name">本文目录</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E7%AB%A0%E4%B8%BB%E7%BA%BF"><span class="toc-text">本章主线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E9%9C%80%E6%B1%82"><span class="toc-text">功能需求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%B9%BF%E7%BB%84%E5%8D%95%E6%92%AD"><span class="toc-text">实现广组单播</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0"><span class="toc-text">谈谈自己实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E5%80%9F%E5%8A%A9STOMP%E5%AE%9E%E7%8E%B0"><span class="toc-text">谈谈借助STOMP实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E9%89%B4%E6%9D%83"><span class="toc-text">实现鉴权</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1"><span class="toc-text">方案设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#STOMP%E5%8D%8F%E8%AE%AE%E5%BB%BA%E7%AB%8B%E6%97%B6%E9%89%B4%E6%9D%83"><span class="toc-text">STOMP协议建立时鉴权</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Websocket%E5%BB%BA%E7%AB%8B%E6%97%B6%E9%89%B4%E6%9D%83"><span class="toc-text">Websocket建立时鉴权</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%AE%A1%E7%90%86%E8%BF%9E%E6%8E%A5"><span class="toc-text">实现管理连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%AE%89%E5%85%A8"><span class="toc-text">实现安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></div></div></div>


</div>
<footer class="footer dis-select"><div class="social-wrap"><a class="social" title="GitHub" href="https://github.com/shibd/" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/gyl-coder/blogImgs@main/blog/img/social/github.svg"/></a><a class="social" title="Spotify" href="https://open.spotify.com/" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/gyl-coder/blogImgs@main/blog/img/social/music.svg"/></a><a class="social" title="Unsplash" href="https://unsplash.com/" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/gyl-coder/blogImgs@main/blog/img/social/music.svg"/></a><a class="social" title="Comments" href="/about/#comments" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/gyl-coder/blogImgs@main/blog/img/social/message.svg"/></a></div></footer>

    </aside>
    <div class='l_main'>
      

      


<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/websocket%E6%8E%A8%E9%80%81%E4%B8%AD%E5%BF%83/">Websocket推送中心</a></div><div id="post-meta">发布于&nbsp;<time datetime="2019-08-16T00:00:00.000Z">2019年8月16日</time></div></div>

<article class='content md post'>
<h1 class="article-title"><span>Websocket推送中心(二)-基于Stomp的推送中心设计</span></h1>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>本文是WebSocket推送中心的第二章节， 本系列文章是在Spring Websocket Stomp的基础上实现的推送系统，计划包含如下几篇文章：</p>
<p><strong>第一篇</strong>：<a href="../message-center-1">Spring Websocket Stomp介绍</a><br><br><strong>第二篇</strong>：<a href="../message-center-2">基于Websocket Stomp的推送中心实现</a><br><br><strong>第三篇</strong>：<a href="../message-center-3">推送中心单机支持百万级连接的晋级之路</a><br><br><strong>第四篇</strong>：<a href="../message-center-4">推送中心的集群架构方案设计落地</a><br></p>
<h3 id="本章主线"><a href="#本章主线" class="headerlink" title="本章主线"></a>本章主线</h3><p>上篇文章介绍了Spring WebSocket STOMP相关内容，奠定了推送中心使用Websocket协议来做，采用Spring Websocket STOMP框架快速实现了简单的服务端到客户端的推送。</p>
<p>本篇从推送中心设计开始，分享推送中心如何支持多项目，如何安全建立链接，如何对客户端鉴权，如何实现广播，多播，以及点对点等内容。</p>
<h3 id="功能需求"><a href="#功能需求" class="headerlink" title="功能需求"></a>功能需求</h3><p>推送中心的目标是为了满足全公司的后端推送业务的，从功能上需要满足多个项目同时接入，同时项目与项目之间数据要完全隔离，不能<code>电商项目</code>的广播消息被<code>理财项目</code>给接收到了。为了说明推送中心的功能需要，请看下图。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/image/message-center/architecture2.jpg"></p>
<ol>
<li>推送中心要支持支持广播，组播，单播接口。例如电商项目可以支持给所有客户端发送消息(<code>广播</code>)，也可以指定给所有地点为上海的客户端发送消息(<code>多播</code>)，也可以指定给用户1发送消息(<code>单播</code>)。</li>
<li>推送中心要有鉴权功能，客户端连接推送中心时推送中心要能校验客户端是否合法。</li>
<li>推送中心要灵活管理连接，实时查看客户端连接情况，主动断开与某个客户端的连接等功能。</li>
<li>推送中心要有黑白名单功能，能防御恶意连接，能防御DDOS攻击。</li>
<li>推送中心要高可用，支持高并发连接。</li>
</ol>
<p>本文分享上述1，2，3，4解决方案。如何高可用如何支持高并发连接在第三篇和第四篇分享。</p>
<h3 id="实现广组单播"><a href="#实现广组单播" class="headerlink" title="实现广组单播"></a>实现广组单播</h3><h4 id="谈谈自己实现"><a href="#谈谈自己实现" class="headerlink" title="谈谈自己实现"></a>谈谈自己实现</h4><p>在谈论如何使用Websocket实现广播、组播、单播之前，我们先来明确一下WebSocket的本质。WebSocket其实是客户端和服务端<code>多对1</code>建立的长连接，对于服务端(<code>推送中心</code>)来说，它和N个客户端连接，所以它自然可以给每个连接打<code>tag</code>，比如他可以标机一条连接是电商项目的用户1，另一条连接是理财项目的<code>shanghai</code>组。所以我们可以在应用内部设计这样一个映射表来实现:</p>
<blockquote>
<p><code>Map&lt;项目ID, Map&lt;主题, List&lt;链接&gt;&gt;&gt;</code> <br></p>
</blockquote>
<p>其中主题是很灵活的，在不同的模式下，可以前后端约定好值即可，例如：</p>
<ul>
<li>广播：主题约定设置为<code>all</code>，客户端订阅all，服务端找到所有订阅<code>all</code>的客户端连接，逐条推送即可完成广播。</li>
<li>多播：主题前后端约定好，比如客户端可以根据地区，订阅<code>shanghai</code>的主题，那么服务端就可以找到所有订阅<code>shanghai</code>的连接，逐条推送完成多播。</li>
<li>单播：主题约定为前端传的<code>userId</code>，或者<code>设备唯一id</code>，服务端还是根据主题找到连接，推送即可。</li>
</ul>
<h4 id="谈谈借助STOMP实现"><a href="#谈谈借助STOMP实现" class="headerlink" title="谈谈借助STOMP实现"></a>谈谈借助STOMP实现</h4><p>看到这里其实已经明白，所谓的广播、多播、单播，在WebSocket下就是<code>主题</code>和<code>链接</code>的关系。客户端订阅唯一的主题就是单播，客户端都订阅相同的主题就是广播，某一些客户端订阅相同的主题就是多播。这和第一章我们聊的STOMP协议是相似的，我把上篇的相关代码拿过来。</p>
<p>实际上Spring WebSocket STOMP的实现就是维护了类似于<code>destination</code>和<code>连接</code>的关系，这里的<code>destination</code>就是客户端订阅的目录格式的路径，感兴趣的同学可以翻阅官方源码类<code>SessionSubscriptionRegistry</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// javascript客户端订阅主题</span></span><br><span class="line">stompClient.subscribe(<span class="string">&#x27;/topic/greetings&#x27;</span>, function (greeting) &#123;</span><br><span class="line">    <span class="comment">// 服务端发送消息，客户端收到展示</span></span><br><span class="line">    showGreeting(JSON.parse(greeting.body).content);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 订阅单用户消息</span></span><br><span class="line">stompClient.subscribe(<span class="string">&#x27;/user/queue/&#x27;</span> + project + <span class="string">&#x27;/&#x27;</span>, function (greeting) &#123;</span><br><span class="line">    showGreeting(<span class="string">&#x27;UserMessage: &#x27;</span> + JSON.parse(greeting.body).content);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// java服务端向该主题发送消息</span></span><br><span class="line">messagingTemplate.convertAndSend(<span class="string">&quot;/topic/greetings&quot;</span>,</span><br><span class="line"> <span class="keyword">new</span> Greeting(<span class="string">&quot;Hello, &quot;</span> + HtmlUtils.htmlEscape(message.getName()) + <span class="string">&quot;!&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上，我们可以使用STOMP协议加上和项目约定好订阅路径来实现多项目下的广播、多播和单播。我们约定STOMP的订阅路径为:</p>
<blockquote>
<p><code>/topic/projcetId/xxx</code> <br><br><br><code>topic</code>: 统一订阅的根路径名称。<br><br><code>projcetId</code>: 项目Id, 必传 <br><br><code>xxx</code>: <code>xxx</code>可以自定义，可以前后端约定为<code>all</code>来实现广播，也可以定义子路径为<code>/greetings/group1</code>来实现多播。也可以定义为<code>唯一设备id</code>来实现单播。</p>
</blockquote>
<p>Spring WebSocket STOMP还支持针对认证的用户单独发送消息，你可以认为这也是多播的一种方案(因为同一个用户有可能多个客户端建立连接)，约定STOMP订阅路径为：</p>
<blockquote>
<p><code>/user/queue/</code></p>
</blockquote>
<p>推送中心和项目客户端以上述约定格式建立ws连接后，项目后端可以通过调用推送中心暴露的restful接口推送消息。接口入参如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;projectId&quot;</span>: <span class="string">&quot;电商项目id&quot;</span>,</span><br><span class="line">  <span class="string">&quot;playLoad&quot;</span>: <span class="string">&quot;&#123;\&quot;content\&quot;:\&quot;解析我,做你想做的事情\&quot;&#125;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;topic&quot;</span>: <span class="string">&quot;all/group1/&quot;</span>,</span><br><span class="line">  <span class="string">&quot;updateTime&quot;</span>: <span class="number">1557676800000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>项目客户端</code>、<code>推送中心</code>、<code>项目后端</code>间完整调用流程为：</p>
<ol>
<li><code>项目客户端</code>向推送中心建立WebSocket连接，并调用subscribe订阅，传入和后端约定好的主题<code>shanghai</code>，完整订阅路径:<code>/topic/projectId/shanghai</code>。</li>
<li><code>推送中心</code>根据前端链接鉴权(后面会说)，同意建立连接，然后根据订阅的路径维护<code>订阅路径</code>与<code>连接</code>间的关系。</li>
<li><code>项目后端</code>调用推送中心的REST接口，传入<strong>projectId</strong>和<strong>topic</strong>以及<strong>playLoad</strong>。</li>
<li><code>推送中心</code>根据projectId和topic找到一堆或一个客户端链接发送消息。</li>
</ol>
<h3 id="实现鉴权"><a href="#实现鉴权" class="headerlink" title="实现鉴权"></a>实现鉴权</h3><h4 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h4><p>客户端在和推送中间建立ws连接时需要鉴权，如果一个不合法的客户端成功和Websocket建立链接，那么就可以收到他想窃听的消息。客户端和推送中心建立ws连接时，推送中心需要去找业务系统确认客户端的合法性，具体实现方案有很多种。</p>
<p>期初想的方案很直白，比如下述鉴权流程：</p>
<ol>
<li>建立ws之前，先客户端拿着业务系统给的token，再发送到业务系统； <br></li>
<li>业务系统后端再到推送服务去拿key（因为对于推送服务，业务系统的后端是可信赖的）；<br></li>
<li>然后业务系统后端把key返回给客户端；<br></li>
<li>客户端用key再构造ws的url，尝试和推送服务建立长连接，推送服务从url里提取key，校验合法性，accept连接</li>
</ol>
<p>这种方案虽然没问题，但是交互复杂，而且没法识别用户。我理想的交互方式是在对客户端鉴权时不要让推送中心和项目后盾最交互。其实推送中心对客户端鉴权，我认为是JWT的一种典型场景，JWT就像是业务系统颁布的合法的签名，推送中心作为第三方部门系统，是认可这个签名的。具体步骤如下，关于JWT相关推荐<a href="">文章</a></p>
<ol>
<li>业务系统使用推送中心初始化公钥，推送中心维护项目和公钥的集合。</li>
<li>客户端正常登陆业务系统，业务系统使用私钥生成jwt颁布给客户端。 </li>
<li>客户端鉴权时传入projectId和jwt，推送中心根据projectId获取公钥，然后通过公钥校验，通过连接建立成功，不通过，连接建立失败。</li>
</ol>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/image/message-center/auth.jpg"></p>
<h4 id="STOMP协议建立时鉴权"><a href="#STOMP协议建立时鉴权" class="headerlink" title="STOMP协议建立时鉴权"></a>STOMP协议建立时鉴权</h4><blockquote>
<p>The WebSocket protocol, RFC 6455 “doesn’t prescribe any particular way that servers can authenticate clients during the WebSocket handshake.” In practice, however, browser clients can use only standard authentication headers (that is, basic HTTP authentication) or cookies and cannot (for example) provide custom headers. Likewise, the SockJS JavaScript client does not provide a way to send HTTP headers with SockJS transport requests. See sockjs-client issue 196. Instead, it does allow sending query parameters that you can use to send a token, but that has its own drawbacks (for example, the token may be inadvertently logged with the URL in server logs).</p>
</blockquote>
<p>Spring Websocket STOMP<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#websocket-stomp-authentication-token-based">官网</a>在Token Authenication中说到，由于WebSocket协议并没有规定在WebSocket握手期间对客户端进行身份认证，而且SockJS JavaScript客户端不提供建立连接时自定义请求头，但是允许传入请求参数，所以我们可以把token放到请求参数当中。</p>
<p>Spring Websocket STOMP官网没有选择把token在ws握手时传入，推荐在创建STOMP协议时带入token到服务端认证，通过创建<code>ChannelInterceptor</code>实现，可以参见<a target="_blank" rel="noopener" href="https://github.com/shibd/socket.io.java.server.biz/tree/done/stomp">推送中心完整项目地址</a></p>
<p>客户端在STOMP建立时传入JWT</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">stompClient = Stomp.over(socket);</span><br><span class="line">stompClient.connect(&#123;</span><br><span class="line">    <span class="attr">token</span>: token,</span><br><span class="line">    <span class="attr">projectId</span>: projectId</span><br><span class="line">&#125;, connectCallback, errorCallback);</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接失败时的回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">errorCallback</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(res属于鉴权失败) &#123;</span><br><span class="line">    <span class="comment">// 取消连接，调用回调函数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(res属于服务端不存在或者网络错误) &#123;</span><br><span class="line">    <span class="comment">// 隔段时间重试</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端配置STOMP认证管道校验JWT，Spring Boot官方为配置一个<code>Inbound</code>的拦截器，拦截<code>Connect</code>请求，这其实是属于STOMP的第一次握手时鉴权。但是只配置<code>Inbound</code>只能设置鉴权用户和设置用户，并不能把</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocketMessageBroker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> <span class="keyword">implements</span> <span class="title">WebSocketMessageBrokerConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 配置STOMP认证管道</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> registration</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureClientInboundChannel</span><span class="params">(ChannelRegistration registration)</span> </span>&#123;</span><br><span class="line">        registration.interceptors(<span class="keyword">new</span> ChannelInterceptor() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Message&lt;?&gt; preSend(Message&lt;?&gt; message, MessageChannel channel) &#123;</span><br><span class="line">                StompHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);</span><br><span class="line">                <span class="keyword">if</span> (StompCommand.CONNECT.equals(accessor.getCommand())) &#123;</span><br><span class="line">                    Map&lt;String, LinkedList&gt; headers = (Map) message.getHeaders()</span><br><span class="line">                            .get(SimpMessageHeaderAccessor.NATIVE_HEADERS);</span><br><span class="line">                    <span class="comment">// 鉴权,校验失败会抛出异常,通过ws把消息给到客户端</span></span><br><span class="line">                    Principal user = authenticate(headers);</span><br><span class="line">                    accessor.setUser(user);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> message;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Websocket建立时鉴权"><a href="#Websocket建立时鉴权" class="headerlink" title="Websocket建立时鉴权"></a>Websocket建立时鉴权</h4><p>上述官方推荐在建立STOMP协议时鉴权，虽然socket js不支持修改ws的headers，但是也可以放在请求入参中完成在WebSocket握手时鉴权。相关代码如下</p>
<p>客户端在WS建立时传入JWT</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> SockJS(<span class="string">&#x27;/msg-center/websocket?token=&#x27;</span> + token + <span class="string">&quot;&amp;projectId=&quot;</span> + projectId)</span><br><span class="line">stompClient = Stomp.over(socket);</span><br><span class="line">stompClient.connect(&#123;&#125;, connectCallback, errorCallback);</span><br></pre></td></tr></table></figure>
<p>服务端配置拦截器校验JWT</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册STOMP协议节点并映射url</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerStompEndpoints</span><span class="params">(StompEndpointRegistry registry)</span> </span>&#123;</span><br><span class="line"> registry</span><br><span class="line">     <span class="comment">// 注册一个 /websocket 的 websocket 节点</span></span><br><span class="line">     .addEndpoint(<span class="string">&quot;/websocket&quot;</span>).addInterceptors()</span><br><span class="line">     <span class="comment">// 添加 websocket握手拦截器</span></span><br><span class="line">     .addInterceptors(myHandshakeInterceptor())</span><br><span class="line">     <span class="comment">// 添加 websocket握手处理器</span></span><br><span class="line">     .setHandshakeHandler(myDefaultHandshakeHandler())</span><br><span class="line">     <span class="comment">// 设置允许可跨域的域名(一定程度预防CSRF攻击)</span></span><br><span class="line">     .setAllowedOrigins(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">     <span class="comment">// 指定使用SockJS协议</span></span><br><span class="line">      .withSockJS();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * WebSocket 握手拦截器 可做一些用户认证拦截处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> HandshakeInterceptor <span class="title">myHandshakeInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> HandshakeInterceptor() &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * websocket握手连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回是否同意握手</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">beforeHandshake</span><span class="params">(ServerHttpRequest request, ServerHttpResponse response,</span></span></span><br><span class="line"><span class="params"><span class="function">        WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes)</span> </span>&#123;</span><br><span class="line">      ServletServerHttpRequest req = (ServletServerHttpRequest) request;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 根据token认证用户，不通过返回拒绝握手</span></span><br><span class="line">      String token = req.getServletRequest().getParameter(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">      String projectId = req.getServletRequest().getParameter(<span class="string">&quot;projectId&quot;</span>);</span><br><span class="line">      Principal user = authenticate(projectId, token);</span><br><span class="line">      <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 保存会话信息</span></span><br><span class="line">      attributes.put(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">      attributes.put(<span class="string">&quot;remoteUrl&quot;</span>, request.getRemoteAddress());</span><br><span class="line">      attributes.put(<span class="string">&quot;projectId&quot;</span>, projectId);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterHandshake</span><span class="params">(ServerHttpRequest request, ServerHttpResponse response,</span></span></span><br><span class="line"><span class="params"><span class="function">        WebSocketHandler wsHandler, Exception exception)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * WebSocket 握手处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> DefaultHandshakeHandler <span class="title">myDefaultHandshakeHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> DefaultHandshakeHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Principal <span class="title">determineUser</span><span class="params">(ServerHttpRequest request, WebSocketHandler wsHandler,</span></span></span><br><span class="line"><span class="params"><span class="function">        Map&lt;String, Object&gt; attributes)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 设置认证通过的用户到当前会话中</span></span><br><span class="line">      <span class="keyword">return</span> (Principal) attributes.get(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="实现管理连接"><a href="#实现管理连接" class="headerlink" title="实现管理连接"></a>实现管理连接</h3><p>在Spring Web STOMP中可以使用<code>SimpUserRegistry</code>对象获取所有<code>session</code>的集合。推送中心在支持多项目的情况下，对<code>SimpUserRegistry</code>结果做了处理，支持分项目分订阅主题来查看连接，但是暂时不能对连接做修改。样例数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&quot;data&quot;: [</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;projectId&quot;: &quot;fm&quot;,</span><br><span class="line">    &quot;wsUserSessionVos&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;userId&quot;: &quot;wudixiaobaozi&quot;,</span><br><span class="line">        &quot;sessions&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;sessionId&quot;: &quot;jdtcl3r4&quot;,</span><br><span class="line">            &quot;remoteUrl&quot;: &quot;/127.0.0.1:52476&quot;,</span><br><span class="line">            &quot;subscriptions&quot;: [</span><br><span class="line">              &quot;/user/queue/fm/&quot;,</span><br><span class="line">              &quot;/topic/fm/all/group1/dss&quot;</span><br><span class="line">            ]</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;sessionId&quot;: &quot;fyhgruy5&quot;,</span><br><span class="line">            &quot;remoteUrl&quot;: &quot;/127.0.0.1:52465&quot;,</span><br><span class="line">            &quot;subscriptions&quot;: [</span><br><span class="line">              &quot;/topic/fm/all/group1/&quot;,</span><br><span class="line">              &quot;/user/queue/fm/&quot;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="实现安全"><a href="#实现安全" class="headerlink" title="实现安全"></a>实现安全</h3><p>其实WebSocket涉及很多安全性的问题，笔者目前还没实验踩坑，后续会单独对安全性进行测试，感兴趣的可以先参考<a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/85999">该篇文章</a>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇介绍了如何使用Spring WebSocket STOMP支持多项目下广播，多播，单播推送设计，通过前后端约定主题，后端调用推送中心restful接口实现。另外介绍了推送中心的鉴权方案设计，以及两种实现方式。可参考</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/shibd/socket.io.java.server.biz/tree/done/stomp">推送中心完整代码</a>。</p>
</blockquote>
<p>到现在为止，单体的推送中心设计已经结束，后续会分享单体推送中心服务器调优达到百万级长连接，以及推送中心的集群方案设计。</p>


<div class="article-footer reveal fs14"><section id="license"><div class="header"><span>许可协议</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div></section></div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="header cap theme"><span>接下来阅读</span></section><section class="body fs14"><a id="next" href="/message-center-1/">Websocket推送中心(一)-Spring Websocket Stomp介绍<span class="note">较早</span></a><div class="line"></div><a id="prev" href="/message-center-3/">Websocket推送中心(三)-单机100W连接(C1000K)达成<span class="note">较新</span></a><div class="line"></div><a id="more" href="/archives">检索全部文章</a></section></div>






  <div class='related-wrap md reveal' id="comments">
    <div class='cmt-title cap theme'>
      快来参与讨论吧
    </div>
    <div class='cmt-body beaudar'>
      

<svg class="loading" style="vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg>

<div id="beaudar" repo="shibd/shibd.github.io" issue-term="pathname" theme="preferred-color-scheme" input-position="top" comment-order="desc" loading="false" branch="master"></div>

    </div>
  </div>



      
<footer class="page-footer reveal fs12"><hr><div class="sitemap"><div class="sitemap-group"><span class="fs14">Blog</span><a href="/">Recent Update</a><a href="/blog/categories/">Categories</a><a href="/blog/tags/">Tags</a><a href="/blog/archives/">Archives</a></div><div class="sitemap-group"><span class="fs14">Wiki</span><a href="/wiki/tags/%E6%8A%80%E6%9C%AF%E5%8A%A0%E6%B2%B9%E7%AB%99/">技术加油站</a><a href="/wiki/">...</a></div><div class="sitemap-group"><span class="fs14">Social</span><a href="/friends/">Friends</a><a href="/about/#comments">Comments</a><a target="_blank" rel="noopener" href="https://open.spotify.com/">Spotify</a></div><div class="sitemap-group"><span class="fs14">More</span><a href="/about/">About</a><a href="/wiki/resume">Resume</a><a target="_blank" rel="noopener" href="https://github.com/shibd">GitHub</a></div></div><div class="text"><object data="https://img.shields.io/static/v1?label=强力驱动&message=Hexo&style=social&logo=Hexo&logoColor=0E83CD&link=https://hexo.io/"></object>&nbsp;&nbsp;<object data="https://img.shields.io/static/v1?label=网站部署&message=GitHub&style=social&logo=GitHub&logoColor=181717&link=https://github.com/shibd"></object>&nbsp;&nbsp;<object data="https://img.shields.io/static/v1?label=网站部署&message=Vercel&style=social&logo=Vercel&logoColor=000000&link=https://vercel.com"></object> &nbsp;&nbsp;<object data="https://img.shields.io/static/v1?label=图片分发&message=jsDelivr&style=social&logo=jsDelivr&logoColor=E84D3D&link=https://www.jsdelivr.com/"></object>&nbsp;&nbsp;<object data="https://img.shields.io/static/v1?label=域名解析&message=Aliyun&style=social&logo=Alibaba Cloud&logoColor=FF6A00&link=https://www.aliyun.com/"></object>&nbsp;&nbsp;<object data="https://img.shields.io/static/v1?label=许可协议&message=CC BY-NC-SA 4.0&style=social&logo=Creative Commons&logoColor=EF9421&link=https://creativecommons.org/licenses/by-nc-sa/4.0/"></object>&nbsp;&nbsp;<object data="https://img.shields.io/static/v1?label=博客作者&message=Baozi&style=social&logo=Blogger&logoColor=FF5722&link=https://shibd.github.io/"></object>&nbsp;&nbsp;<object data="https://img.shields.io/static/v1?label=原创主题&message=Stellar&style=social&logo=Badoo&logoColor=783BF9&link=https://github.com/xaoxuu/hexo-theme-stellar/tree/1.4.0"></object>&nbsp;&nbsp;</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.4.1';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js',
    sitesjs: '/js/plugins/sites.js',
    friendsjs: '/js/plugins/friends.js',
  };

  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.3.1/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper/swiper-bundle.min.css","js":"https://unpkg.com/swiper/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://cdn.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://cdn.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->

  <script>
  function loadBeaudar() {
    const els = document.querySelectorAll("#comments #beaudar");
    if (els.length === 0) return;
    els.forEach((el, i) => {
      try {
        el.innerHTML = '';
      } catch (error) {
        console.log(error);
      }
      var script = document.createElement('script');
      script.src = 'https://beaudar.lipk.org/client.js';
      script.async = true;
      for (let key of Object.keys(el.attributes)) {
        let attr = el.attributes[key];
        if (['class', 'id'].includes(attr.name) === false) {
          script.setAttribute(attr.name, attr.value);
        }
      }
      el.appendChild(script);
    });
  }
  window.addEventListener('DOMContentLoaded', (event) => {
      loadBeaudar();
  });
</script>




<!-- inject -->


  </div>
</body>
</html>
